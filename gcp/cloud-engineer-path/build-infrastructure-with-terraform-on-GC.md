# Build Infrastructure with Terraform on Google Cloud

## Terraform Fundamentals
The set of files used to describe infrastructure in Terraform is simply known as a Terraform configuration. The format of the configuration files can be found in the Terraform Language Documentation. We recommend using JSON for creating configuration files.

The "resource" block in the instance.tf file defines a resource that exists within the infrastructure. A resource might be a physical component such as an VM instance.

The resource block has two strings before opening the block: the **resource type** and the **resource name**.

The Execution Plan describes the actions Terraform will take in order to change real infrastructure to match the configuration. The output format is similar to the diff format generated by tools like Git.

There is a + next to google_compute_instance.terraform, which means that Terraform will create this resource. Following that are the attributes that will be set. When the value displayed is <computed>, it means that the value won't be known until the resource is created.

commands:
-  create an empty file: `touch instance.tf`
- `terraform taint` recreate the something. E.g.: `terraform taint google_compute_instance.vm_instance`

## IaC with Terraform
Summary of the workflow:
1. Scope: Confirm what resources need to be created for a given project.
1. Author: Create the configuration file in HCL based on the scoped parameters.
1. Initialize: Run terraform init in the project directory with the configuration files. This will download the correct provider plug-ins for the project.
1. Plan & Apply: Run terraform plan to verify creation process and then terraform apply to create real resources as well as the state file that compares future changes in your configuration files to what actually exists in your deployment environment.

Terraform block:
- it is required so Terraform knows which provider to download from the Terraform Registry. 
- hashicorp/google is the shorthand for registry.terraform.io/hashicorp/google.
- The version argument is optional, but recommended. f the version isn't specified, Terraform will automatically download the most recent provider during initialization.

Providers:
- it is used to configure the named provider
- A provider is responsible for creating and managing resources. 
- Multiple provider blocks can exist if a Terraform configuration manages resources from different providers.

As you change Terraform configurations, Terraform builds an execution plan that only modifies what is necessary to reach your desired state. By using Terraform to change infrastructure, you can version control not only your configurations but also your state so you can see how the infrastructure evolves over time.

Destructive changes:
- It is a change that requires the provider to replace the existing resource rather than updating it.
- This usually happens because the cloud provider doesn't support updating the resource in the way described by your configuration.
- The prefix -/+ means that Terraform will destroy and recreate the resource, 
- E.g.: Changing the disk image of an instance

Destroy infrastructure:
- completely destroy your Terraform-managed infrastructure.
- Destroying your infrastructure is a rare event in production environments. But if you're using Terraform to spin up multiple environments such as development, testing, and staging, then destroying is often a useful action.
- it behaves as if all of the resources have been removed from the configuration.
- Just like with terraform apply, Terraform determines the order in which things must be destroyed. 

Saving the plan:
1. `terraform plan -out static_ip` **Saving the plan this way ensures that you can apply exactly the same plan in the future.**
1. `terraform apply "static_ip"` 

The order that resources are defined in a terraform configuration file has no effect on how Terraform applies your changes. Organize your configuration files in a way that makes the most sense for you and your team.

#### Implicit and explicit dependencies
Implicit: Terraform can automatically infer when one resource depends on another.
- E.g.: the reference to `google_compute_address.vm_static_ip.address` creates an implicit dependency 
- Implicit dependencies via interpolation expressions are the primary way to inform Terraform about these relationships, and should be used whenever possible.

Explicit:
- Sometimes there are dependencies between resources that are not visible to Terraform.
- The `depends_on` argument can be added to any resource and accepts a list of resources to create explicit dependencies for.

#### Defining a provisioner
To define a provisioner, modify the resource block. Multiple provisioner blocks can be added to define multiple provisioning steps. Terraform supports many provisioners, but for this example you are using the local-exec provisioner.

The `local-exec` provisioner executes a command locally on the machine running Terraform, not the VM instance itself.

The output may be confusing at first. Terraform found nothing to do - and if you check, you'll find that there's no ip_address.txt file on your local machine.Terraform treats provisioners differently from other arguments.**Provisioners only run when a resource is created,** but adding a provisioner does not force that resource to be destroyed and recreated.

---

Failed provisioners and tainted resources:
- if a resource is successfully created but fails a provisioning step, Terraform will error and mark the resource as tainted.
- A resource that is tainted still exists, but shouldn't be considered safe to use, since provisioning failed.
- When you generate your next execution plan, Terraform will remove any tainted resources and create new resources, attempting to provision them again after creation.

---
Destroy provisioners
- Provisioners can also be defined that run only during a destroy operation.
- These are useful for performing system cleanup, extracting data, etc

## Interact with Terraform Modules
A Terraform module is a set of Terraform configuration files in a single directory. Even a simple configuration consisting of a single directory with one or more .tf files is a module. When you run Terraform commands directly from such a directory, it is considered the **root module**.

Terraform commands will only directly use the configuration files in one directory, which is usually the current working directory. Your configuration can use **module blocks** to call modules in other directories. When Terraform encounters a module block, it loads and processes that module's configuration files.

Modules can be loaded from either the local filesystem or a remote source. 

Module best practices:
- Start writing your configuration with a plan for modules. 
- Use local modules to organize and encapsulate your code. *Even if you aren't using or publishing remote modules, organizing your configuration in terms of modules from the beginning will significantly reduce the burden of maintaining and updating your configuration as your infrastructure grows in complexity.*
- Use the public Terraform Registry to find useful modules. *This way you can quickly and confidently implement your configuration by relying on the work of others.*
- Publish and share modules with your team. Most infrastructure is managed by a team of people, and modules are an important tool that teams can use to create and maintain infrastructure.
- Google recommends that you create every Terraform configuration with the assumption that it may be used as a module, because this will help you design your configurations to be flexible, reusable, and composable.

## Interact with Terraform Modules

Create a Terraform configuration
```bash
git clone https://github.com/terraform-google-modules/terraform-google-network
cd terraform-google-network
git checkout tags/v6.0.1 -b v6.0.1
```

Set values for module input variables: Some input variables are required, which means that the module doesn't provide a default value

Define root input variables: Using input variables with modules is very similar to how you use variables in any Terraform configuration. A common pattern is to identify which module input variables you might want to change in the future, and then create matching variables in your configuration's variables.tf file with sensible default values. Those variables can then be passed to the module block as arguments.

```tf
# In variables.tf
variable "project_id" {
  description = "The project ID to host the network in"
  default     = "FILL IN YOUR PROJECT ID HERE"
}

# Back in the main.tf file
module "test-vpc-module" {
  ...
  project_id   = var.project_id
  ...
}
```

Define root output values: Modules also have output values, which are defined within the module with the output keyword. You can access them by referring to `module.<MODULE NAME>.<OUTPUT NAME>`. Like input variables, module outputs are listed under the outputs tab.

When using a new module for the first time, you must run either `terraform init` or `terraform get` to install the module.

---

Module structure:
- LICENSE
- README.md
- main.tf
- variables.tf
- outputs.tf
*Note: None of these files are required or has any special meaning to Terraform when it uses your module. You can create a module with a single .tf file or use any other file structure you like.*

Each of these files serves a purpose:
- LICENSE: contains the license under which your module will be distributed. When you share your module, the LICENSE file will let people using it know the terms under which it has been made available. Terraform itself does not use this file.
- README.md: contains documentation in markdown format that describes how to use your module. Terraform does not use this file, but services like the Terraform Registry and GitHub will display the contents of this file to visitors to your module's Terraform Registry or GitHub page.
- main.tf: contains the main set of configurations for your module. You can also create other configuration files and organize them in a way that makes sense for your project.
- variables.tf: contains the variable definitions for your module. When your module is used by others, the variables will be configured as arguments in the module block. Because all Terraform values must be defined, any variables that don't have a default value will become required arguments. A variable with a default value can also be provided as a module argument, thus overriding the default value.
- outputs.tf: contains the output definitions for your module. Module outputs are made available to the configuration using the module, so they are often used to pass information about the parts of your infrastructure defined by the module to other parts of your configuration.

*Be aware of these files and ensure that you don't distribute them as part of your module:*
- terraform.tfstate and terraform.tfstate.backup
- .terraform
- *.tfvars
*Note: If you are tracking changes to your module in a version control system such as Git, you will want to configure your version control system to ignore these files. For an example, see this .gitignore file from GitHub.*
